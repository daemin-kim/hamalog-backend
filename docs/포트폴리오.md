## 1. 프로젝트 개요

- **프로젝트명**: Hamalog (하마로그)
- **개발 기간**: 2025.08 ~ 현재 (약 5개월)
- **수행 방식**: 개인 프로젝트
- **담당 범위**: 백엔드 전담 (설계, 구현, 테스트, 배포, 문서화 100%)
- **배포 현황**: 운영 중 (Cloudflare Tunnel 기반 Zero Trust 배포)
    - GitHub: https://github.com/daemin-kim/Hamalog
- **기술 스택**: Java 21, Spring Boot 3.4.5, Spring Data JPA, Spring Security, JWT, MySQL 8.0, Redis 7, Flyway, Docker, Cloudflare Tunnel, Prometheus

---

## 2. 요구사항 및 나의 역할

### 💼 개요

> 복약 스케줄, 마음 일기, 부작용 추적을 통합 관리하는 헬스케어 백엔드 시스템
>

### 📌 요구사항 요약

- 인증/보안: JWT 기반 Stateless 인증, CSRF 방어, Rate Limiting, OAuth2 소셜 로그인
- 복약 관리: 스케줄 CRUD, 알림 시간 관리, 복약 기록 추적, 이행률 통계
- 마음 일기: 템플릿/자유 형식 작성, 기분 통계, 캘린더 조회, 하루 1회 제한
- 부작용 추적: 다중 부작용 기록, 정도 평가, Redis 캐싱
- 알림 시스템: Redis Stream 기반 비동기 메시지 큐, FCM 푸시 알림, DLQ 모니터링
- 데이터 내보내기: JSON/CSV 형식 (GDPR 대응)

### 👨‍💻 담당 역할

- 전체 백엔드 아키텍처 설계 및 구현 (레이어드 아키텍처, AOP 횡단 관심사)
- 50+ REST API 엔드포인트 개발
- JWT + CSRF 이중 보호, AES-256-GCM 암호화 등 보안 체계 구축
- 1,300+ 테스트 케이스 작성 (단위/통합/아키텍처 테스트)
- ADR 7개, 패턴 가이드 6개 등 기술 문서화

---

## 3. 기술 스택 및 아키텍처

| 항목 | 사용 기술 / 라이브러리 |
| --- | --- |
| 언어 | Java 21 (OpenJDK), Kotlin 2.0.21 (DTO, 유틸리티) |
| 빌드 도구 | Gradle |
| 프레임워크 | Spring Boot 3.4.5, Spring Security, Spring Data JPA |
| 인증/보안 | JWT (jjwt 0.12.6), OAuth2 (카카오), AES-256-GCM 암호화 |
| 데이터베이스 | MySQL 8.0, Redis 7, Flyway (마이그레이션) |
| 메시지 큐 | Redis Stream (Producer/Consumer 패턴) |
| 모니터링 | Micrometer, Prometheus, Grafana |
| 테스트 | JUnit 5, Mockito, AssertJ, ArchUnit, JaCoCo |
| 문서화 | SpringDoc OpenAPI 2.7.0 |
| CI/CD | GitHub Actions |
| 배포 | Docker, Cloudflare Tunnel (Zero Trust), Nginx |

### 📐 아키텍처 특징

- **레이어드 아키텍처**: Controller → Service → Domain → Repository 계층 분리
- **AOP 횡단 관심사**: 소유권 검증(@RequireResourceOwnership), 로깅, 성능 측정, 재시도
- **Zero Trust 배포**: Cloudflare Tunnel을 통한 외부 포트 노출 없는 보안 연결
- **로그 분리**: application.log, security.log, audit.log, performance.log 4종 분리
- **캐시 전략**: Redis 기반 Cache-Aside 패턴, TTL 기반 자동 갱신

---

## 4. 주요 기능

| 기능 | 설명 |
| --- | --- |
| 🔐 인증/보안 | JWT + CSRF 이중 보호, Refresh Token Rotation, Rate Limiting (Sliding Window), OAuth2 (카카오), 다중 디바이스 세션 관리 |
| 💊 복약 관리 | 스케줄 CRUD, 복용 시간/알람 타입 설정, 이미지 업로드 (5MB), 배치 기록 (최대 100건), 이행률 통계 (일/주/월별), 그룹 관리 |
| 📔 마음 일기 | 템플릿(4단계 질문) / 자유 형식 선택, 하루 1회 제한, 기분 통계 (분포, 연속 작성일), 캘린더 뷰 |
| ⚠️ 부작용 추적 | 다중 부작용 동시 기록, 정도 평가 (1-5단계), Redis 캐시 기반 최근 5건 빠른 조회 |
| 🔔 알림 시스템 | Redis Stream 비동기 메시지 큐, FCM 푸시 알림, 3회 재시도 후 DLQ 적재, Discord Webhook 운영 알림 |
| 📤 데이터 내보내기 | 전체 데이터 JSON 내보내기, 복약 기록 CSV (의사 상담용), GDPR 대응 |

---

## 5. 문제 해결 및 기술적 도전

### ✅ 문제 사례 1: SPA 환경에서 CSRF 공격 취약점

> JWT만으로는 쿠키에 토큰 저장 시 CSRF 공격에 취약. 악의적인 사이트에서 인증된 요청 위조 가능.
>
> → 해결 방법: JWT + CSRF 이중 보호 패턴 채택. Redis 기반 CSRF 토큰 관리 (60분 TTL), 상태 변경 요청(POST/PUT/DELETE) 시 검증, Refresh Token Rotation으로 토큰 탈취 시 피해 최소화.
>
> → 결과: CSRF 공격 완전 차단, Stateless 아키텍처 유지하여 수평 확장 가능.
>
> → 선택 근거: SPA에서 쿠키 기반 인증을 유지하면서도 CSRF를 방어해야 했고, 세션 기반 전환은 Stateless 구조와 배치되어 이중 보호가 가장 현실적이라고 판단.
>
> → 고려한 대안: 
> - Option A: 쿠키 대신 Authorization 헤더 사용 (XSS 위험이 커지고 보관 전략 재정의 필요)
> - Option B: 전통적 세션 + CSRF (Stateful로 전환되어 확장성 저하)
> - Option C: SameSite 강화만 적용 (보호 범위가 브라우저/환경에 의존)
>
> → 트레이드오프: Redis 의존성 및 토큰 동기화 비용 증가 vs Stateless 유지와 공격면 축소.
>
> → 사고 흐름: 공격 시나리오 확인 → 세션 전환 비용 평가 → 헤더 방식 보관 리스크 분석 → 이중 보호가 비용 대비 효과 최적이라고 결론.

### ✅ 문제 사례 2: 리소스 소유권 검증 코드 중복

> 모든 API에서 "요청자가 해당 리소스의 소유자인지" 검증하는 코드가 중복 (약 200줄+). 검증 누락 위험 및 유지보수 어려움.
>
> → 해결 방법: AOP 기반 선언적 소유권 검증 어노테이션 `@RequireResourceOwnership` 구현. 어노테이션 한 줄로 소유권 검증 완료.
>
> → 결과: 검증 로직 중복 제거 (200줄 → 1줄), 검증 누락 방지, 관심사 분리 (비즈니스 로직 ↔ 보안 로직).
>
> → 선택 근거: 반복되는 보안 검증은 누락 위험이 높아 선언적 방식이 필요했고, AOP가 공통 관심사에 가장 적합.
>
> → 고려한 대안:
> - Option A: 공통 유틸 메서드 호출 (호출 누락 위험 존재)
> - Option B: 베이스 컨트롤러/서비스 상속 (유연성 저하, 다중 상속 불가)
> - Option C: 인터셉터 전역 처리 (리소스 타입별 맥락 전달이 어려움)
>
> → 트레이드오프: 런타임 AOP 오버헤드 및 디버깅 복잡도 증가 vs 선언적 보안과 누락 방지.
>
> → 사고 흐름: 중복 위치 파악 → 누락 리스크 측정 → 계층별 적용성 비교 → AOP가 가장 낮은 비용으로 일관성 확보.

### ✅ 문제 사례 3: JPA N+1 문제로 인한 성능 저하

> 복약 스케줄 목록 조회 시 연관된 Member, MedicationTime 엔티티 추가 조회로 N+1 쿼리 발생. 10개 조회 시 21개 쿼리.
>
> → 해결 방법: @EntityGraph로 연관 엔티티 함께 조회, DTO Projection으로 필요한 필드만 조회, 배치 조회 (IN 절 사용).
>
> → 결과: 쿼리 수 21개 → 1~2개로 감소 (95% 개선), 목록 조회 응답 시간 약 70% 단축.
>
> → 선택 근거: 조회 화면은 읽기 중심이며 필요한 필드가 제한적이어서, 명시적 페치 전략과 프로젝션 조합이 가장 효율적.
>
> → 고려한 대안:
> - Option A: 모든 연관관계 EAGER (초기 로딩 비용 증가, 예측 어려움)
> - Option B: Hibernate default batch size만 설정 (상황에 따라 효과 제한)
> - Option C: QueryDSL로 전면 재작성 (도입 비용과 복잡도 증가)
>
> → 트레이드오프: 코드 분기/DTO 관리 부담 증가 vs 쿼리 수 절감과 응답 시간 개선.
>
> → 사고 흐름: 쿼리 로그로 N+1 확인 → 화면 요구 필드 최소화 → 페치 전략 후보 비교 → EntityGraph + DTO 조합으로 선택.

### ✅ 요약 버전 (간략)

- **CSRF 취약점**: SPA 쿠키 인증 유지 필요 + Stateless 우선 → JWT + CSRF 이중 보호 선택 (대안 대비 확장성/보안 균형)
- **소유권 검증 중복**: 누락 위험 최소화가 우선 → AOP 선언적 검증 채택 (유틸/상속/인터셉터 대비 일관성 확보)
- **JPA N+1**: 읽기 중심/필드 제한 → EntityGraph + DTO 프로젝션 조합 (EAGER/배치만/QueryDSL 대비 비용-효과 최적)

## 6. 협업 및 커뮤니케이션

- **ADR (Architecture Decision Records)**: 7개 주요 아키텍처 결정 근거 문서화
- **패턴 가이드**: 보안, 캐싱, JPA, 에러처리 등 6개 패턴 가이드 작성
- **GitHub Issue/Project**: 칸반 보드를 활용한 태스크 관리 및 진행 상황 추적
- **AI 협업**: GitHub Copilot, Cursor IDE를 활용한 생산성 향상 경험
- **문서화 습관**: API 명세서 (900+ 줄), 코딩 컨벤션 (400+ 줄) 작성

---

## 7. 개발 결과 및 회고

### 📈 결과

| 지표 | 수치 |
| --- | --- |
| API 엔드포인트 | 50+ 개 |
| 테스트 케이스 | 1,300+ 개 |
| 테스트 커버리지 | 80%+ (JaCoCo 기준) |
| ADR 문서 | 7개 |
| 패턴 가이드 | 6개 |

### 🤔 회고

- **보안**: JWT + CSRF 이중 보호, Refresh Token Rotation의 실무 적용 경험을 쌓음
- **성능**: N+1 해결, 캐싱 전략, 비동기 처리로 응답 시간 최적화 방법을 터득함
- **설계**: AOP를 활용한 선언적 프로그래밍으로 관심사 분리의 장점을 체감함
- **테스트**: ArchUnit으로 아키텍처 규칙을 코드로 강제하는 경험을 쌓음
- **문서화**: ADR, 패턴 가이드 작성을 통해 설계 결정의 근거를 명확히 기록하는 습관을 형성함

### 🚀 향후 개선 방향

- QueryDSL 도입으로 복잡한 동적 쿼리 최적화
- Grafana 대시보드 구축 및 알림 임계값 설정
- 프론트엔드 개발 (React/Flutter) 및 모바일 앱 출시
